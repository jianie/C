#include <stdio.h> //표준 입출력 함수 사용을 위한 헤더
//printf, scanf ..
//#include <stdlib.h> //표준 라이브러리 함수 사용을 위한 헤더
//system, srand ..
#include <time.h> //시간 함수 사용을 위한 헤더
//time ..
#include <Windows.h> //윈도우즈 함수 사용을 위한 헤더
//system, srand, sleep ..

//함수 원형 선언 미리 이러한 구조의 함수가 있다고 컴파일러에게 알려주는 것
void bingoGameStart(int*); //빙고 시작 함수, 반환형이 없으며 매개변수로 int 포인터(배열 변수)를 받음
void printRecord(int*); //전적(기록) 출력 함수, 위와 동일
void init(int*); //빙고판 초기화 함수, 위와 동일
int checkBingo(int*); //빙고 체크 함수, int형을 반환하며 매개변수로 int 포인터(배열 변수)를 받음
void printBingoBoard(int*); //빙고판 출력 함수, 위와 동일
void inputNum(int*, int*); //숫자 입력 함수, 위와 동일한 매개변수 두 개
void randNum(int*, int*); //랜덤 숫자 지정 함수, 위와 동일
//각 함수에 대한 설명은 함수 구현부에 주석..

int main() //메인함수 시작, 반환형은 int, 매개변수 void(없음)
{
	int menu; //1, 2, 3번 메뉴를 입력 받아줄 변수
	int record[3] = { 0 }; //전적을 보관할 배열
	while (1) //프로그램 종료 메뉴를 입력하기 전까지 무한 반복한다.
	{
		printf("1. 빙고 게임 시작\n");
		printf("2. 전적 보기\n");
		printf("3. 프로그램 종료\n");
		scanf_s("%d", &menu); //메뉴 입력
		switch (menu) //입력에 따른 처리
		{
		case 1:
			//게임 시작 전적을 보관할 배열의 이름을 적는다.
			bingoGameStart(record);
			//배열 변수의 변수명은 포인터 변수의 변수명과 같다.
			//n차원 포인터와 n차원 배열은 동일하다고 봐도 된다. 사용법 또한 동일
			break;
		case 2:
			printRecord(record);
			break;
		case 3:
			//프로그램 종료
			return 0;
		default:
			//메뉴 외 입력은 아무것도 하지 않도록 한다.
			break;
		}
		system("pause"); //계속하려면 아무 키나 누르십시오 ... 라는 메세지가 나오며 일시 정지한다.
		system("cls"); //화면을 깨끗하게 지워준다.
		//이 두 함수를 통해서 매번 화면이 깔끔하게 갱신되도록 한다.
	}
	return 0;
}

//빙고 시작 함수 매개변수로 넘어온 주소를 int *record 라는 변수에 대입함으로써
//record는 해당 주소를 가리키는 변수가 되고 이를 통해 main내의 변수에 접근할 수 있게 된다.
//그래서 게임이 종료된 후 승패 결과를 record에 적용하면 main내의 변수가 수정되는 것이다.
void bingoGameStart(int* record)
{
	int userBingo[25]; //유저의 빙고판, 무조건 5x5다.
	int comBingo[25]; //컴퓨터의 빙고판
	int userCount; //유저의 빙고수
	int comCount; //컴퓨터의 빙고수
	int isTurn = 0; //현재 유저의 턴인지, 컴퓨터의 턴인지 구분하기 위한 스위치 변수
	//이 값이 1이면 유저의 턴이다.
	srand((unsigned int)time(NULL)); // rand 랜덤 함수의 시드값을 현재 시간으로 지정한다.
	//rand함수는 시드값에 따라 동일한 랜덤값이 나올 수 있으므로 매번 실행할 때마다
	//다른 시드를 지정하여 완전한 랜덤값이 나올 수 있도록 하는 것이다.
	init(userBingo); //유저 빙고 초기화
	init(comBingo); //컴퓨터 빙고 초기화
	//두 배열 다 1~25가 채워진 후 뒤섞인 상태가 된다.
	while (1) //승패가 갈리기 전까지 무한반복한다.
	{
		userCount = checkBingo(userBingo); //유저의 빙고수를 체크하여 변수에 대입한다.
		comCount = checkBingo(comBingo); //컴퓨터의 빙고수를 체크하여 변수에 대입한다.
		printBingoBoard(userBingo); //유저의 빙고판을 보여준다. 컴퓨터의 빙고판은 보여주지 않는다.
		//컴퓨터의 빙고판도 보여주려면 printBingoBoard(comBingo); 를 추가하고
		//system("cls"); 문장을 함수 내에서가 아닌 이 함수 호출 전에 추가하면 깔끔하게 나온다.

		//각각 빙고수를 출력해준다.
		printf("사용자 : %d줄 빙고\n", userCount);
		printf("컴퓨터 : %d줄 빙고\n", comCount);
		//만약 유저의 빙고수가 5를 넘으며 현재 유저의 턴인 경우
		//혹은 유저의 빙고수가 5를 넘으며 컴퓨터의 빙고수가 5를 넘지 못한 경우 유저의 승리다.
		if ((userCount >= 5 && isTurn) || (userCount >= 5 && comCount < 5))
		{
			//승리 조건을 출력하며 전적을 증가시킨다.
			printf("사용자의 %d줄 빙고로 승리했습니다.\n", userCount);
			record[0]++; //전적 증가
			record[1]++; //승리 증가
			break; //반복 종료
		}
		//컴퓨터의 빙고수가 5를 넘으면 패배
		//(유저의 빙고수가 5를 넘지 못하거나 넘어도 컴퓨터의 턴인 경우)
		else if (comCount >= 5)
		{
			//패배 조건을 출력하며 전적을 증가시킨다.
			printf("컴퓨터의 %d줄 빙고로 패배했습니다.\n", comCount);
			record[0]++; //전적 증가
			record[2]++; //패배 증가
			break;
		}
		//현재 턴을 바꾼다. 항상 한 번씩 돌아가기 때문에
		isTurn = !isTurn;
		// 초기 순서 isTurn = !0 이건 isTurn = 1과 같고 이후
		//isTurn = !1 이기 때문에 isTurn = 0 이며 그냥 매번 0 1 0 1 0 1 0 1 반복한다고 보면 된다.
		if (isTurn) //그래서 이 값이 1이면 유저에게 입력을 받고
			inputNum(userBingo, comBingo);
		else //0인 경우 컴퓨터가 랜덤한 수를 지정한다.
			randNum(userBingo, comBingo);
		//변수가 유저와, 컴퓨터의 빙고 두 개인 이유는 입력된 숫자와 같은 숫자가 있는 경우
		//두 빙고판 모두에 체크를 해주기 위함이다.
	}
}

//전적(기록) 출력 함수 매개변수로 넘어온 포인터를 배열로 접근하며
//각 승패를 출력한다.
void printRecord(int* record)
{
	//record 배열의 0번째에 값이 0이 아니라면 한 판이라도 한 것이므로
	if (record[0])
	{
		//전적을 출력한다.
		printf("\n********** 현재 전적 **********\n");
		printf("%d전 %d승 %d패\n", record[0], record[1], record[2]);
	}
	//0인 경우 한 판도 하지 않았으므로 아래 메세지를 출력한다.
	else
		printf("전적이 없습니다...\n");
}

//빙고판 초기화 함수 매개변수로 넘어온 배열의 주소를 포인터로 받아
//이 변수로 해당 배열을 동일하게 이용할 수 있다.
//이에 대한 주석 내용은 다른 함수와 달리 보이지만 결국 같은 뜻이다.
//매개변수 int* 들은 모두 동일하다고 보면 된다.
void init(int* bingo)
{
	int i; //반복을 위한 index 변수
	int sour, dest; //맞교환할 두 개의 index를 담아놓을 변수
	int temp; //맞교환을 위해 임시로 값을 보관할 변수
	for (i = 0; i < 25; i++) // i는 0부터 24까지 증가하며
		bingo[i] = i + 1; //배열의 값을 1 ~ 25로 대입 한다.
	//아래는 i가 0부터 99까지 증가 즉, 100번의 반복을 한다는 뜻이고
	//100번 동안 랜덤한 숫자들의 위치를 맞교환해서 뒤섞는 것이다.
	for (i = 0; i < 100; i++)
	{
		sour = rand() % 25; //맞바꿀 위치 각각 2개 지정 rand 함수의 결과를 25로 나눈 나머지를 저장
		dest = rand() % 25; //0 ~ 24라는 값이 들어가게 된다. (= 배열의 인덱스)
		temp = bingo[sour]; //맞바꿀 값을 우선 temp 변수에 저장해둔다.
		bingo[sour] = bingo[dest]; //그리고 그 위치에 다른 값을 저장하고
		bingo[dest] = temp; //이 위치에는 처음에 빼놓은 temp값을 저장한다.
		//이로써 sour 인덱스 위치의 값과 dest 인덱스 위치의 값이 바뀌게 된다.
		//1번 반복에 2개의 숫자 위치가 맞교환 된다.

		//초기에 이런 상태라면     나중엔 이렇게 만들기 위함이다.
		//1 2 3 4 5 ~ 23 24 25     7 16 23 1 ~ 9 20 11

		//한 번의 반복만 확인해본다면
		//1 2 3 4 5 ~ 23 24 25
		//sour = 0, dest = 4
		//5 2 3 4 1 ~ 23 24 25
		//이런식으로 처리가 되어 빙고판을 섞게되는 것이다.
	}
}
//빙고판 출력 함수, 매개변수로 넘어온 배열(빙고판)을
//네모칸 안에 예쁘게 출력해주는 함수다. 
//숫자는 체크된 것이면 # 으로 출력 아니면 숫자 그대로 출력한다.
//매개변수로 넘어온 배열의 주소를 포인터로 받아
//이 변수로 해당 배열을 동일하게 이용할 수 있다.
//이에 대한 주석 내용은 int 포인터(배열 변수)를 매개변수로 받는
//다른 함수와 달리 보이지만 결국 같은 뜻이다.
//매개변수 int* 들은 모두 동일하다고 보면 된다.
void printBingoBoard(int* bingo)
{
	system("cls"); //화면을 깨끗하게 지워준다.
	//빙고판을 그리기 위해 아스키 코드 문자들을 찍어준다. 맨 윗줄 (┌ ─ ┬ ┐ 이런 모양들)
	printf("%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n", 1, 6, 6, 22, 6, 6, 22, 6, 6, 22, 6, 6, 22, 6, 6, 2);
	for (int i = 0; i < 5; i++)	//5X5 행열을 출력하기 위한 행 반복
	{
		for (int j = 0; j < 5; j++)	//5X5 행열을 출력하기 위한 열 반복
			if (bingo[(i * 5) + j] == 35)	//만약 현재 출력할 숫자가 체크된 것이면
				printf("%c #", 5);	//칸 모양과 #을 출력한다. (│ # 이런 모양)
			else	//아닌 경우 칸 모양과 해당 숫자를 출력한다.(2자리 차지 = %2d) (│ 3 이런 모양)
				printf("%c%2d", 5, bingo[(i * 5) + j]);
		printf("%c\n", 5);	//한 줄의 끝 문자를 출력 한 뒤에 개행한다.(│ 이것)
		if (i != 4)	//마지막 행이 아닌 동안에는 계속 중간 줄을 출력한다. (├ ─ ┼ ┤ 이런 모양들)
			printf("%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n", 25, 6, 6, 16, 6, 6, 16, 6, 6, 16, 6, 6, 16, 6, 6, 23);
	}
	//맨 밑줄 칸을 그려준다.
	printf("%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n", 3, 6, 6, 21, 6, 6, 21, 6, 6, 21, 6, 6, 21, 6, 6, 4);
	//아스키코드가 궁금하다면..
	//http://blog.naver.com/lyw94k/220831905619
}

//빙고 체크 함수, 매개변수로 넘어온 배열(빙고판)의
//체크된 것을 모두 확인해서 빙고수를 반환한다.
int checkBingo(int* bingo)
{
	//최대 12개의 빙고 체크판을 0으로 초기화한다.
	//(가로 5개 세로 5개 대각선 2개 = 12개)
	int bingoCheck[12] = { 0 };
	int count = 0;	//빙고수를 저장할 변수이며 함수의 끝에서 이 변수를 반환한다.
	int i, j;//반복을 위한 Index 변수
	//가로, 세로, 대각선 5줄 빙고를 확인한다.
	for (i = 0; i < 5; i++)
	{
		for (j = 0; j < 5; j++)
		{
			//가로 확인(행이 같고 열이 다른 즉 첫줄 왼쪽부터 오른쪽까지, 두번째줄~ 다섯번째줄 쭉)
			if (bingo[i * 5 + j] == 35)
				bingoCheck[i]++;
			//세로 확인(열이 같고 행이 다른 즉 첫열 위부터 아래까지, 두~다섯~ 쭉 동일하게)
			if (bingo[j * 5 + i] == 35)
				bingoCheck[i + 5]++;
		}
		//대각선 확인(행과 열이 같아서 왼쪽 위에서부터 오른쪽 아래쪽으로 가는 대각선을 확인한다.)
		for (j = i; j <= i; j++)
			if (bingo[i * 5 + j] == 35)
				bingoCheck[10]++;
	}
	//왼쪽 아래에서 오른쪽 위로 가는 대각선 빙고를 확인한다.
	for (i = 4; i >= 0; i--)
		for (j = 4 - i; j >= 4 - i; j--)
			if (bingo[i * 5 + j] == 35)
				bingoCheck[11]++;
	//위의 빙고를 확인하는 로직을 잘모르겠다면..
	//종이에 써보면서 손 디버깅을 해보면 왜 그런지 알 수 있다.
	//(그냥 i,j의 값을 순서대로 대입해보면 된다.)
	//위에서 확인한 빙고의 수를 센다.
	for (i = 0; i < 12; i++)
		if (bingoCheck[i] == 5)	//해당 변수의 값이 5이면 빙고이므로 count 변수의 값을 증가한다.
			count++;
	return count;
}

//숫자 입력 함수, 매개변수로 넘어온 유저와 컴퓨터의 배열(빙고판)에
//새로 입력된 수가 이미 체크 되었는지 확인하고
//체크되지 않았으면 체크하도록 한다.
void inputNum(int* userBingo, int* comBingo)
{
	int num;	//유저에게 입력받은 수를 저장할 변수
	int isCheck;	//이미 입력되어 체크된 것인지 확인할 변수
	while (1)	//정상적인 수가 입력될 때까지 무한 반복한다.
	{
		isCheck = 0;	//체크되지 않았다고 초기화하고 시작한다.
		printf("입력 : ");
		scanf_s("%d", &num);
		if (num < 1 || num > 25)	//입력받은 수가 1~25 범위를 벗어난 경우 
			printf("1 ~ 25 사이의 숫자를 입력해주세요\n");	//출력 후 다시 입력받는다.
		else	//정상적인 범위 내의 숫자인 경우
		{
			for (int i = 0; i < 25; i++)	//빙고 배열 25개를 모두 검사해서
			{
				if (userBingo[i] == num)	//입력받은 수와 같은 수가 저장되어 있다면
				{
					userBingo[i] = 35;	//그 값을 35라는 값으로 바꾸고(#의 아스키코드 값)
					isCheck = 1;	//체크가 되었음을 저장한다.
				}
				if (comBingo[i] == num)	//컴퓨터의 빙고판에도 동일하게 적용한다.
				{
					comBingo[i] = 35;	//isCheck 값은 이미 변경했으니 컴퓨터 빙고의 숫자값만 바꿔준다.
				}
			}
			if (isCheck)	//위 반복이 종료되고 체크가 되었으면
				break;	//정상적인 입력으로 인한 체크로 반복을 종료하고
			else	//체크가 안되었으면 정상적인 입력이나 해당 수를 찾지 못한 것이므로
				printf("이미 입력한 숫자입니다.\n");	//해당 문자열을 출력하고 반복한다.
		}
	}
}

//컴퓨터의 숫자 입력 함수, 매개변수로 넘어온 유저와 컴퓨터의 배열(빙고판)에
//새로 정해진 수가 이미 체크 되었는지 확인하고
//체크되지 않았으면 체크하도록 한다.
void randNum(int* userBingo, int* comBingo)
{
	int num;	//컴퓨터가 랜덤으로 정한 수를 저장할 변수
	int isCheck;	//이미 입력되어 체크된 것인지 확인할 변수
	printf("컴퓨터 차례입니다.\n");	//유저에게 컴퓨터의 차례임을 알린다.
	Sleep(1000);	//1초 멈추는 함수를 실행 해 컴퓨터가 고민하는 것처럼 보여준다.(1 = 0.001초, 1000 = 1초)
	while (1)	//이미 입력되지 않은 수가 입력될 때까지 무한 반복한다.
	{
		isCheck = 0;	//체크되지 않았다고 초기화하고 시작한다.
		num = rand() % 25 + 1;	//랜덤 수를 지정한다. rand 함수로 나오는 결과에(0 ~ 32767)
		//% 25 연산을 해서 0 ~ 24 라는 결과를 얻고 + 1 연산을 통해 1 ~ 25 라는 결과값을 얻어낸다.
		for (int i = 0; i < 25; i++)	//빙고 배열 25개를 모두 검사해서
		{
			if (userBingo[i] == num)	//입력받은 수와 같은 수가 저장되어 있다면
			{
				userBingo[i] = 35;	//그 값을 35라는 값으로 바꾸고(#의 아스키코드 값)
				isCheck = 1;	//체크가 되었음을 저장한다.
			}
			if (comBingo[i] == num)	//컴퓨터의 빙고판에도 동일하게 적용한다.
			{
				comBingo[i] = 35;	//isCheck 값은 이미 변경했으니 컴퓨터 빙고의 숫자값만 바꿔준다.
			}
		}
		if (isCheck)	//위 반복이 종료되고 체크가 되었으면
			break;	//정상적인 입력으로 인한 체크로 반복을 종료한다. 반대 경우는 없다.
	}
	printf("컴퓨터가 입력한 숫자 : %d\n", num);	//컴퓨터가 입력한 숫자를 유저에게 알려준다.
	Sleep(1500);	//1.5초 멈춰서 유저가 충분히 반응할 수 있도록 해준다.
}
